= やきなまし法

link:https://atcoder.jp/contests/chokudai004/tasks/chokudai004_a[マス目に数を書き込む問題(Chokudai Contest 004)]
を焼きなまし法でアプローチします．


[NOTE]
====
Kさんの配列設計プログラムもおそらく焼きなましっぽいことをやっていると思われます．
少なくとも山登りはしていると思います．
====

== Step 0：とりあえず動くプログラムを書く (解空間を正しくとらえる)
// {{{

とりあえず条件($l_{ij} \leq a_{ij} \leq r_{ij}$)を満たす適当な解を出力してみよう，
という気持ちになります． +
配列設計で言えば，ランダムにATGCを選んで設計することに対応します．

[NOTE]
====
条件を満たす $a$ を *解* と呼び，今回は9のn^2乗通りくらいの $a$ の選び方があります．
そのすべての解を集めたものを *解空間* と呼び，
解空間を *探索* することでより良い解を探していきます．
すべての解をチェックできれば *最適解* を見つけることができますが，
それは一般に難しいので，焼きなまし法のような近似解法が用いられます．
====

[source, c]
.適当な解を1つ出力するプログラム
----
#include <stdio.h>
#include <stdlib.h>

int n;
int b[3];
int l[30][30];
int r[30][30];
int a[30][30];

int main() {
    //----------------
    // 入力
    //----------------
    scanf("%d %d %d %d", &n, &b[0], &b[1], &b[2]);
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            scanf("%d", &l[i][j]);
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            scanf("%d", &r[i][j]);
        }
    }

    //----------------
    // 探索
    //----------------
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            // l[i][j]以上r[i][j]以下の値をランダムで選ぶ
            a[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
        }
    }

    //----------------
    // 出力
    //----------------
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            printf("%d ", a[i][j]);
        }
        printf("\n");
    }

    return 0;
}
----

このプログラムで666,382点を得ることができました．

// }}}

== Step 1：探索をしてみる (ランダム法)
// {{{

今度は，いくつか解を作ってみて一番良かったものを選ぶことを考えます．
そのためには，解がどのくらい良いかを評価(evaluate)する必要があります．
今回は幸いにも問題中にスコアの定義が書かれています．
自由エネルギーを最小化するという見方にならって，
ここではこのスコアに-1を掛けた値を評価値とします．

[NOTE]
====
評価関数(エネルギー関数)の設計は非常に重要です．
今回は与えられた式(評価関数)をそのまま用いましたが，別の評価関数を用いても良く，
そのほうが探索が上手くいく場合が十分にありえます．
一般に滑らかな関数にするとよいです．

配列設計では，同一塩基の連続，GC含量，2次構造，
自由エネルギーといった複数の特徴量からなる関数になるはずで，
その定義にはセンスが求められます．
====

[source, c]
.ランダム法のプログラム
----
//...

int s[30][30];

// 解sの評価関数(内容は本質的に重要じゃないです)
int eval() {
    int count[3] = {0, 0, 0};
    int sum = 0;
    int score = 0;
    // 好きな値b[k=0, 1, 2]
    for(int k=0;k<3;k++){
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                // ijから下方向にl伸ばしてみる
                sum = 0;
                for(int l=0;l+i<n;l++){
                    sum += s[i+l][j];
                    if(sum == b[k]){
                        count[k]++;
                    }
                }
                // ijから右方向にl伸ばしてみる
                sum = 0;
                for(int l=0;l+j<n;l++){
                    sum += s[i][j+l];
                    if(sum == b[k]){
                        count[k]++;
                    }
                }
            }
        }
        score += b[k]*count[k];
    }
    
    // 小さいほど良くするために符号を反転して返す
    return -score;
}

int main() {
    //...

    //----------------
    // 探索
    //----------------
    int e_best = 0;
    // 1000個の解を試す
    for(int k=0;k<1000;k++){
        // 解sのランダム生成
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                s[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
            }
        }

        // 解sのエネルギー
        int e_now = eval();

        // ベスト解の更新
        if(e_now < e_best){
            e_best = e_now;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    a[i][j] = s[i][j];
                }
            }
        }
    }

    //...
}
----

このプログラムで723,310点を得ることができました．

=== 改善

プログラムの流れを見やすくするために，
解sのランダムな生成とベスト解の更新をそれぞれ `generate`，`update` 関数としてまとめておきます．

[source, c]
.ランダム法のプログラム(改)
----
//...

// 解sのランダム生成
void generate() {
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            s[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
        }
    }
}

// ベスト解の更新
void update() {
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            a[i][j] = s[i][j];
        }
    }
}


int main() {
    //...

    //----------------
    // 探索
    //----------------
    int e_best = 0;
    // 1000個の解を試す
    for(int k=0;k<1000;k++){
        // 解sのランダム生成
        generate();

        // 解sのエネルギー
        int e_now = eval();

        // ベスト解の更新
        if(e_now < e_best){
            e_best = e_now;
            update();
        }
    }

    //...
}
----

// }}}

== Step 2：近傍探索をする (山登り法)
// {{{

せっかく作った解を毎回捨てるのはもったいないです(要出典)．
そこで，その解に少し変更を加え，
似てるけど少し異なる(近い)解を調べていく *近傍探索* をしてみます．

具体的には，適当な $s_{ij}$ を選んでその値を+1あるいは-1します．
配列設計なら，1塩基をランダムに置き換えることなどが考えられます．
その結果エネルギーが大きくなってしまったら元に戻し，
小さくなったらそのままにする，という操作を繰り返します．
したがって悪い方向に探索は進みません．
このアルゴリズムは山登り法と呼ばれています(今回の場合は谷を下っていますが)．

[NOTE]
====
近傍探索の方法も評価関数の設計と同様に非常に重要です．
なるべく小さな移動をすると良いことが経験的に知られています．
====

[source, c]
.山登り法のプログラム
----
//...

int main() {
    //...

    //----------------
    // 探索
    //----------------
    generate();
    for(int k=0;k<1000;k++){

        // 変更を加える場所と量をランダムに決める
        int i = rand()%n;
        int j = rand()%n;
        int d = rand()%2*2-1; // +-1
        // はみ出そうなら処理をスキップ
        if(s[i][j] + d < l[i][j] || s[i][j] + d > r[i][j]){
            continue;
        }

        int e_now  = eval();
        s[i][j] += d; // 変更を加える
        int e_next = eval();

        // 悪化したら元に戻す
        if(e_next > e_now){
            s[i][j] -= d;
        }
    }
    update();

    //...
}
----

このプログラムで901,825点を得ることができました．

=== 改善(時間計測)

ところで，今まで探索回数を1000回に固定してきました．
時間制限いっぱい探索をするには，探索のループを無限ループにして実行時間を計測すればよいです．

たとえば，3秒以内に終わらせたい場合は，余裕を持って2.8秒くらいで打ち切るとよいでしょう．

[source, c]
.山登り法のプログラム(改)
----
//...
#include <time.h>
//...
const double time_max = 2.8;    // 最大探索時間(秒)
//...

int main() {
    clock_t time_start = clock();

    //...

    //----------------
    // 探索
    //----------------
    generate();
    for(int k=0;;k++){
        // 現在までの経過時刻(秒)
        double sec = (double)(clock()-time_start)/CLOCKS_PER_SEC;
        if(sec > time_max){
            break;
        }

        //...
    }

    //...
}
----

このプログラムで1,091,739点を得ることができました．

// }}}

== Step 3：たまには山を下ってみる (焼きなまし法)
// {{{

いよいよ焼きなましをします．

悪化する遷移をある確率で行い，その先にもっと良い解があることを期待します．
その遷移を行う確率 $p$ は，近傍探索の遷移の前後でのエネルギー変化を $\Delta E = E_{\mathrm{after}} - E_{\mathrm{before}}$ とすると，
$\Delta E < 0$ の時 $p=1$ で，
$\Delta E \geq 0$ の時 $p=\exp(-\Delta E/T)$ とします．
ただし， $T$ は温度(temperature)で，
0から1に正規化された時刻をtとした時 $T=\beta\alpha^t$ と定義されます．

$\alpha$ と $\beta$ がハイパーパラメータとなり，
この部分を調整する必要があります．
今回は $\alpha=0.2$，$\beta=20$ 近辺が良さげだという結果があります．

[NOTE]
====
温度の定義などは人によって異なると思います．
====


[source, c]
.焼きなまし法のプログラム
----
//...
const double alpha = 0.2;
const double beta = 20;
//...

int main() {
    //...

    //----------------
    // 探索
    //----------------
    generate();
    double e_best = eval();
    for(int k=0;;k++){
        //...

        int e_before = eval();
        s[i][j] += d; // 変更を加える
        int e_after = eval();

        // 悪化する遷移も行う
        double de = e_after - e_before;
        if(de < 0 || (double)rand()/RAND_MAX < exp(-de/(beta*pow(alpha, sec/time_max)))){
            if(e_after < e_best){
                e_best = e_after;
                update();
            }
        }else{
            s[i][j] -= d;
        }
    }

    //...
}
----

このプログラムで1,140,150点を得ることができました．
// }}}

== Step 4：高速化
編集中
// 時間や計算資源が潤沢に無い場合，特にコンテストなどでは更に高速化などの工夫が必要です．
// 例えば上の点数だとChokudai Contest 004で150位に届かないくらいです．
//
// 一番考えられる高速化は，評価関数の高速化です．
// よく考えてみると $s_{ij}$ を変えた場合は $i$ 行と $j$ 列の変化だけ見れば良いですね．
// エネルギーの差分だけを見れば良いというのはよくある話です．
//
// その他，細々した高速化をし，最終的なプログラムは次のようになりました．
//
// このプログラムで1,304,092点を得ることができました．
//
// [source, c]
// ----
// ----
// }}}

