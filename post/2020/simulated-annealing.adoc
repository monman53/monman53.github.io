= やきなまし法

link:https://atcoder.jp/contests/chokudai004/tasks/chokudai004_a[この最適化問題]
を焼きなまし法でアプローチします．


[NOTE]
====
Kさんの配列設計プログラムもおそらく焼きなましっぽいことをやっていると思われます．
少なくとも山登りはしていると思います．
====

== Step 0：とりあえず動くプログラムを書く (解空間を正しくとらえる)
// {{{

とりあえず条件($l_{ij} \leq a_{ij} \leq r_{ij}$)を満たす適当な解を出力してみよう，
という気持ちになります． +
配列設計で言えば，ランダムにATGCを選んで設計することに対応します．

[NOTE]
====
条件を満たす $a$ を *解* と呼び，今回は9のn^2乗通りくらいの $a$ の選び方があります．
そのすべての解を集めたものを *解空間* と呼び，
解空間を *探索* することでより良い解を探していきます．
すべての解をチェックできれば *最適解* を見つけることができますが，
それは一般に難しいので，焼きなまし法のような近似解法が用いられます．
====

[source, c]
.適当な解を1つ出力するプログラム
----
#include <stdio.h>
#include <stdlib.h>

int n;
int b[3];
int l[30][30];
int r[30][30];
int a[30][30];

int main() {
    //----------------
    // 入力
    //----------------
    scanf("%d %d %d %d", &n, &b[0], &b[1], &b[2]);
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            scanf("%d", &l[i][j]);
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            scanf("%d", &r[i][j]);
        }
    }

    //----------------
    // 探索
    //----------------
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            // l[i][j]以上r[i][j]以下の値をランダムで選ぶ
            a[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
        }
    }

    //----------------
    // 出力
    //----------------
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            printf("%d ", a[i][j]);
        }
        printf("\n");
    }

    return 0;
}
----

このプログラムで666,382点を得ることができました．

// }}}

== Step 1：探索をしてみる (ランダム法)
// {{{

今度は，いくつか解を作ってみて一番良かったものを選ぶことを考えます．
そのためには，解がどのくらい良いかを評価(evaluate)する必要があります．
今回は幸いにも問題中にスコアの定義が書かれています．
自由エネルギーを最小化するという見方にならって，
このスコアに-1を掛けた値を評価値とします．

[NOTE]
====
評価関数(エネルギー関数)の設計は非常に重要です．
今回は与えられた式(評価関数)をそのまま用いましたが，別の評価関数を用いても良く，
そのほうが探索が上手くいく場合が十分にありえます．
一般に滑らかな関数にするとよいです．

配列設計では，同一塩基の連続，GC含量，2次構造，
自由エネルギーといった複数の特徴量からなる関数になるはずで，
その定義にはセンスが求められます．
====

[source, c]
.ランダム法のプログラム
----
#include <stdio.h>
#include <stdlib.h>

int n;
int b[3];
int l[30][30];
int r[30][30];
int s[30][30];
int a[30][30];

// 解sの評価関数(内容は本質的に重要じゃないです)
int eval() {
    int count[3] = {0, 0, 0};
    int sum = 0;
    int score = 0;
    // 好きな値b[k=0, 1, 2]
    for(int k=0;k<3;k++){
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                // ijから下方向にl伸ばしてみる
                sum = 0;
                for(int l=0;l+i<n;l++){
                    sum += s[i+l][j];
                    if(sum == b[k]){
                        count[k]++;
                    }
                }
                // ijから右方向にl伸ばしてみる
                sum = 0;
                for(int l=0;l+j<n;l++){
                    sum += s[i][j+l];
                    if(sum == b[k]){
                        count[k]++;
                    }
                }
            }
        }
        score += b[k]*count[k];
    }
    
    // 小さいほど良くするために符号を反転して返す
    return -score;
}

int main() {
    //----------------
    // 入力
    //----------------
    //...

    //----------------
    // 探索
    //----------------
    int e_best = 0;
    // 1000個の解を試す
    for(int k=0;k<1000;k++){
        // 解sのランダム生成
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                s[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
            }
        }

        // 解sのエネルギー
        int e_now = eval();

        // ベスト解の更新
        if(e_now < e_best){
            e_best = e_now;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    a[i][j] = s[i][j];
                }
            }
        }
    }

    //----------------
    // 出力
    //----------------
    //...

    return 0;
}
----

このプログラムで723,310点を得ることができました．

プログラムの流れを見やすくするために，
解sのランダムな生成とベスト解の更新をそれぞれ `generate`，`update` 関数としてまとめておきます．

[source, c]
.ランダム法のプログラム(改)
----
#include <stdio.h>
#include <stdlib.h>

int n;
int b[3];
int l[30][30];
int r[30][30];
int s[30][30];
int a[30][30];

// 解sの評価関数(内容は本質的に重要じゃないです)
int eval() {
    //...
}

// 解sのランダム生成
void generate() {
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            s[i][j] = l[i][j] + rand()%(r[i][j]-l[i][j]+1);
        }
    }
}

// ベスト解の更新
void update() {
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            a[i][j] = s[i][j];
        }
    }
}


int main() {
    //----------------
    // 入力
    //----------------
    //...

    //----------------
    // 探索
    //----------------
    int e_best = 0;
    // 1000個の解を試す
    for(int k=0;k<1000;k++){
        // 解sのランダム生成
        generate();

        // 解sのエネルギー
        int e_now = eval();

        // ベスト解の更新
        if(e_now < e_best){
            e_best = e_now;
            update();
        }
    }

    //----------------
    // 出力
    //----------------
    //...

    return 0;
}
----

// }}}
