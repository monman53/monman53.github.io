<!doctype html><html lang='ja'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width, initial-scale=1'><link rel='shortcut icon' type='image/png' href='/images/favicon.png'/><title>競技プログラミング : monman53</title><link rel='stylesheet' href='/styles/highlight.css'><script src='/scripts/highlight.pack.js'></script><script>hljs.initHighlightingOnLoad();</script><script id='MathJax-script' async src='/scripts/mathjax/tex-chtml.js'></script><script type='text/x-mathjax-config'>MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><link rel='stylesheet' href='/styles/main.css'><!-- Global site tag (gtag.js) - Google Analytics --><script async src='https://www.googletagmanager.com/gtag/js?id=UA-111264044-1'></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-111264044-1');</script></head><body><header><div class='pad'><p class='bread'><a href='/'>monman53.github.io</a> / <a href='/computer/'>computer</a> / <a href='/computer/kyopro.html'>kyopro.html</a></p><p style='font-size: small;'>Last Modified : 2018-06-19 06:36:40 +0900</p></div></header><article><div class='pad'><h1>競技プログラミング</h1><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>競プロのお供．</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ライブラリ">ライブラリ</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/header.h">&#8594;header</a></p>
</div>
<div class="paragraph">
<p><a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/geometry.h">&#8594;geometry</a>
<a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/datastructure.h">&#8594;datastructure</a>
<a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/graph.h">&#8594;graph</a>
<a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/graph_flow.h">&#8594;graph_flow</a>
<a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/math.h">&#8594;math</a>
<a href="https://raw.githubusercontent.com/monman53/online_judge/master/lib/string.h">&#8594;string</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_英語笑">英語（笑）</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">at most</dt>
<dd>
<p>高々</p>
</dd>
<dt class="hdlist1">at least</dt>
<dd>
<p>少なくとも</p>
</dd>
<dt class="hdlist1">acute angle</dt>
<dd>
<p>鋭角</p>
</dd>
<dt class="hdlist1">ascending order</dt>
<dd>
<p>小さい順に，昇順，A-Z，1-9</p>
</dd>
<dt class="hdlist1">coincide</dt>
<dd>
<p>一致する</p>
<div class="ulist">
<ul>
<li>
<p>No two points coincide. 2点は異なる． (CF432div2C)</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">descending order</dt>
<dd>
<p>大きい順に，降順，Z-A，9-1</p>
</dd>
<dt class="hdlist1">distinct</dt>
<dd>
<p>互いに異なる，同様でない</p>
</dd>
<dt class="hdlist1">obtuse angle</dt>
<dd>
<p>鈍角</p>
</dd>
<dt class="hdlist1">respectively</dt>
<dd>
<p>それぞれ，おのおの</p>
</dd>
<dt class="hdlist1">strictly less than &#8230;&#8203;</dt>
<dd>
<p>&#8230;&#8203;より小さい</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_教訓">教訓</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ハマった時にチェックすべきこと">ハマった時にチェックすべきこと</h3>
<div class="ulist">
<ul>
<li>
<p>最大（小）値での初期化に用いている値は，十分大きい（小さい）か</p>
</li>
<li>
<p>特殊な入力(0とか)でのWAであるだけではないか(特にCodeForces)</p>
</li>
<li>
<p>どうしても計算量を落とせない時は，鳩の巣原理で打ち切りを考える．(CF 432 div2 C)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_その他">その他</h3>
<div class="ulist">
<ul>
<li>
<p>range based forはautoを使え(longにするべきところをintにしたことがある)．</p>
</li>
<li>
<p>A，Bではmin，maxで簡潔に解ける場合がある．</p>
</li>
<li>
<p>Hackはプログラムをよく見て慎重に行う</p>
</li>
<li>
<p>再提出は慎重に．そのままでも正解かもしれないから，本当になおすべきか見極める．</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_テクニック">テクニック</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// 二分探索(半開区間)
int l = 0;
int r = n;
while(l != r){
    int c = (l+r)/2;
    if(v[c] == value){
        flag = true;
        break;
    }
    if(v[c] &lt; value){
        l = c+1;
    }else{
        r = c;
    }
}

// 天井関数( a/b )
(a+b-1)/b

// λ関数でソート
sort(v.begin(), v.end(), [](struct E &amp;e1, struct E &amp;e2){return e1.v &lt; e2.v;});

// ビット演算
i &amp; -i; // iの最後の1のビット

// パスカルの三角形
LL comb[n+1][n+1];
for(int i=0;i&lt;=n;i++){
    for(int j=0;j&lt;=n;j++){
        if(j &gt; i){
            comb[i][j] = 0LL;
        }else if(j == 0 || j == i){
            comb[i][j] = 1LL;
        }else{
            comb[i][j] = comb[i-1][j-1]+comb[i-1][j];
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_問題">問題</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_グラフ">グラフ</h3>
<div class="ulist">
<ul>
<li>
<p>ベルマンフォード</p>
<div class="ulist">
<ul>
<li>
<p>最短路，負閉路検出(到達可能な負閉路(全ての負閉路を検出してはだめ))</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://beta.atcoder.jp/contests/abc061/tasks/abc061_d">ABC061D</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_知識">知識</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_グラフ_2">グラフ</h3>
<div class="ulist">
<ul>
<li>
<p>任意のトーナメントグラフにはハミルトンパスが存在する(AOJ2386 Sightseeing Tour)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_定義">定義</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">単純グラフ</dt>
<dd>
<p>多重辺，ループのないグラフ</p>
</dd>
<dt class="hdlist1">2部グラフ</dt>
<dd>
<p>頂点集合を2つの部分集合に分割して，各集合内の頂点同士の間には辺が無いようなグラフ</p>
</dd>
<dt class="hdlist1">完全グラフ</dt>
<dd>
<p>任意の2頂点間に枝があるグラフ</p>
</dd>
<dt class="hdlist1">DAG (Directed Acyclic Graph)</dt>
<dd>
<p>閉路のない有向グラフ</p>
<div class="ulist">
<ul>
<li>
<p>全ての辺が左から右に向くように，各頂点を一直線上に並べることができる．これをトポロジカル順序という．</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">トーナメントグラフ</dt>
<dd>
<p>任意の2頂点が1つの有向辺で結ばれているグラフ</p>
</dd>
<dt class="hdlist1">ハミルトン(閉)路</dt>
<dd>
<p>全頂点を一度だけ通る(閉)路</p>
</dd>
<dt class="hdlist1">オイラー(閉)路</dt>
<dd>
<p>全辺を一度だけ通る(閉)路</p>
</dd>
<dt class="hdlist1">ハミルトングラフ</dt>
<dd>
<p>ハミルトン閉路を含むグラフ</p>
</dd>
<dt class="hdlist1">準ハミルトングラフ</dt>
<dd>
<p>ハミルトン閉路は含まないが，ハミルトン路は含むグラフ</p>
</dd>
<dt class="hdlist1">オイラーグラフ</dt>
<dd>
<p>オイラー閉路を含むグラフ</p>
</dd>
<dt class="hdlist1">準オイラーグラフ</dt>
<dd>
<p>オイラー閉路は含まないが，オイラー路は含むグラフ</p>
</dd>
<dt class="hdlist1">(強)連結</dt>
<dd>
<p>無(有)向グラフにおいて，任意の2頂点間に路が存在すること</p>
</dd>
<dt class="hdlist1">(強)連結成分</dt>
<dd>
<p>(強)連結な頂点集合に分解した際の各集合</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_c">C++</h2>
<div class="sectionbody">
<div class="paragraph">
<p>断りがない限りC++11を想定しています．</p>
</div>
<div class="paragraph">
<p><a href="https://cpprefjp.github.io/">cpprefjp</a></p>
</div>
<div class="sect2">
<h3 id="_リファレンス">リファレンス</h3>
<div class="sect3">
<h4 id="_algorithm">algorithm</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;algorithm&gt;

// 集合演算
sort(a.begin(), a.end()); // ソートしておく
sort(b.begin(), b.end()); // ソートしておく
vector&lt;T&gt; ab; // ab は必要分の長さを取らなくても良い
// 積集合
set_intersection(a.begin(), a.end(),
                 b.begin(), b.end(),
                 inserter(ab, ab.end()));
// 和集合           set_union
// 差集合           set_difference
// 互いに素な集合   set_symmetric_difference

// 要素の最大値を指す最初のイテレータを取得
cout &lt;&lt; *max_element(v.begin(), v.end()) &lt;&lt; endl;

// 指定された要素以上の値が現れる最初の位置のイテレータを取得
// ない場合はend()などのlastが返る
cout &lt;&lt; *lower_bound(v.begin(), v.end(), a) &lt;&lt; endl;

// lower_boundとupper_boundで要素のカウント
vector&lt;int&gt; v = {0, 5, 4, 3, 6, 4, 5, 3, 3};
sort(v.begin(), v.end());
int n = upper_bound(v.begin(), v.end(), 3) -
        lower_bound(v.begin(), v.end(), 3);
cout &lt;&lt; n &lt;&lt; endl; // 3

// next_permutation
// vはソートしておく
do{
    ...
}while(next_permutation(v.begin(), v.end()));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bitset">bitset</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;bitset&gt;

bitset&lt;8&gt; bit(131uL);

cout &lt;&lt; bit &lt;&lt; endl;             // 10000011
cout &lt;&lt; bit.to_string() &lt;&lt; endl; // 10000011
cout &lt;&lt; bit.to_ullong() &lt;&lt; endl; // 131

// 1になっているビットの数
bitset&lt;4&gt; bs("1011");
cout &lt;&lt; bs.count() &lt;&lt; endl; // 3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map">map</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;map&gt;

// 検索
if(m.find(key) != m.end()){
    ...
}

// range based for
for(auto kv : m){
    auto key    = kv.fist;
    auto value  = kv.second;
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_queue">queue</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;queue&gt;

// queue
q.push(v);
auto v = q.front();
q.pop();

// priority queue
pq.push(v);
auto v = pq.top();
pq.pop();

// priority queue は標準で降順なので，ダイクストラで使うときは次のようにする
priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; pq;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_set">set</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;set&gt;

s.insert(v);
s.erase(v); // O(N)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stack">stack</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;stack&gt;

s.push(v);
auto v = s.top();
s.pop();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_string">string</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;

// substr
s.substr(2, 3)  // 2番目(0-index)から3要素
s.substr(2);    // 2番目(0-index)以降全て


// 行読み込み
getline(cin, str);

// 文字を結合するときは+=かpush_back等を使う
str += 'c';

// range based for ももちろん可
for(auto c : str){
    cout &lt;&lt; c &lt;&lt; endl;
}

// 文字列部分比較
if(str.compare(offset, 4, "hoge") == 0){
    ...
}

// 末尾位置文字を取り除く
s.pop_back();

// 文字列反転
// algorithm の reverse を用いる
reverse(str.begin(), str.end());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_utility">utility</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;utility&gt;

// swap
swap(v[4], v[5]);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_vector">vector</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

// 100個の0で初期化
vector&lt;int&gt; vec(100, 0);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_言語機能">言語機能</h3>
<div class="sect3">
<h4 id="_debug">Debug</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// uncomment to disable assert()
//#define NDEBUG
#include &lt;cassert&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_range_based_for_statement">range-based for statement</h4>
<div class="paragraph">
<p><a href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html">range based for</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// 非破壊，eを変更可
for(auto e : es){
    ...
}

// 破壊，eを変更可
for(auto &amp;e : es){
    ...
}

// 非破壊，eを変更不可
for(const auto &amp;e : es){
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div></div></article><footer><div class='pad'><p>Last Modified : 2018-06-19 06:36:40 +0900</p><p><a href='/'>monman53.github.io</a></p><p>This page is generated by <a href='https://github.com/monman53/monsta'>monsta</a>.</p><p><a rel='license' href='http://creativecommons.org/licenses/by/4.0/'><img alt='Creative Commons License' style='border-width:0' src='/images/cc-by.png' height='30px'/></a><br>This work is licensed under a <a rel='license' href='http://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 International License</a>.</p></div></footer></body></html>
